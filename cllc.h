//#############################################################################
//
// FILE:   cllc.h
//
// TITLE: This is the solution header file.
//
//#############################################################################

#ifndef CLLC_H
#define CLLC_H

#ifdef __cplusplus

extern "C" {
#endif

//
// the includes & defines
//
#include <stdint.h>
#include <stddef.h>

// #ifndef __TMS320C28XX_CLA__
#include <math.h>
// #else
// #include <CLAmath.h>
// #endif

//
// this is the file generated by the powerSUITE page for this system
//
#include "cllc_settings.h"
#include "cllc_hal.h"

//
// Library header files
// DCL Library is used for the controller implementation
// GI -> DF13,
// GV -> DF13,
//

#ifndef __TMS320C28XX_CLA__
#include "DCL/DCLF32.h"
#define GI DCL_DF13
#define GV DCL_DF13

//
// GI on C28x ,run DCL_DF13 routines
//
#define GI_IMMEDIATE_RUN DCL_runDF13_C5
#define GI_PRECOMPUTE_RUN DCL_runDF13_C6

//
// GV on C28x ,run DCL_DF13 routines
//
#define GV_RUN DCL_runDF13_C4
#define GV_IMMEDIATE_RUN DCL_runDF13_C5
#define GV_PRECOMPUTE_RUN DCL_runDF13_C6

#else
#include "DCLCLA.h"
#define GI DCL_DF13_CLA
#define GV DCL_DF13_CLA

//
// GI on C28x ,run DCL_DF13 routines
//
#define GI_IMMEDIATE_RUN runDF13_L5
#define GI_PRECOMPUTE_RUN runDF13_L6

//
// GV on C28x ,run DCL_DF13 routines
//
#define GV_IMMEDIATE_RUN runDF13_L5
#define GV_PRECOMPUTE_RUN runDF13_L6

#pragma FUNC_ALWAYS_INLINE(runDF13_L5)
#pragma FUNC_ALWAYS_INLINE(runDF13_L6)

//
//! \brief          Executes an immediate 3rd order Direct Form 1 controller on
//!                 the FPU32, Implemented as inline C function
//! \param[in] p    Pointer to the DCL_DF13 controller structure
//! \param[in] ek   The servo error
//! \param[in] vk   The partial pre-computed control effort
//! \return         The control effort
//!
static inline float32_t runDF13_L5(DCL_DF13_CLA *p,
                                             float32_t ek,
                                             float32_t vk)
{
    p->d4 = (ek * p->b0) + vk;

    return(p->d4);
}

//
//! \brief          Executes a partial pre-computed 3rd order
//!                 Direct Form 1 controller on the FPU32
//!                 Implemented as inline C function
//!                 Note: d0 not used
//! \param[in] p    Pointer to the DCL_DF13 controller structure
//! \param[in] ek   The servo error
//! \param[in] uk   The controller output in the previous sample interval
//! \return         The control effort
//!
//
static inline float32_t runDF13_L6(DCL_DF13_CLA *p,
                                             float32_t ek,
                                             float32_t uk)
{
    float32_t v9;

    v9 = (ek * p->b1) + (p->d1 * p->b2) + (p->d2 * p->b3)
         - (uk * p->a1) - (p->d5 * p->a2) - (p->d6 * p->a3);
    p->d2 = p->d1;
    p->d1 = ek;
    p->d6 = p->d5;
    p->d5 = uk;

    return(v9);
}

#endif

#include "utilities/emavg.h"

#pragma FUNC_ALWAYS_INLINE(EPWM_setActionQualifierContSWForceAction)

//
// Function to run the ISR3, for details see dataflow diagram in the user guide
//
void runISR3(void);

//
// Function initialize the global variables
//
void initGlobalVariables(void);

//
// Function reads the trip flags and updates the board status enum type variable
//
void updateBoardStatus(void);

//
//
//
void setBuildLevelIndicatorVariable(void);
void changeSynchronousRectifierPwmBehavior(uint16_t powerFlow);

//
// typedefs
//

typedef union{
    enum
    {
        Lab1 = 0,
        Lab1_CLA = 1,
        Lab2 = 2,
        Lab2_CLA = 3,
        Lab3 = 4,
        Lab3_CLA = 5,
        Lab4 = 6,
        Lab4_CLA = 7,
        Lab5 = 8,
        Lab5_CLA = 9,
        Lab6 = 10,
        Lab6_CLA = 11,
        Lab7 = 12,
        Lab7_CLA = 13,
        Lab8 = 14,
        Lab8_CLA = 15,
        undefinedLab = 12,
    }Lab_Enum;
    int32_t pad;
}Lab_EnumType;

extern  Lab_EnumType lab;

typedef union{
    enum
    {
        noTrip = 0,
        primOverCurrentTrip = 1,
        secOverCurrentTrip = 2,
        primOverVoltageTrip = 3,
        secOverVoltageTrip = 4,
        primTankOverCurrentTrip = 5,
    }TripFlag_Enum;
    int32_t pad;
}TripFlag_EnumType;

extern  TripFlag_EnumType TripFlag;

typedef union{
    enum
    {
        pwmSwState_disabledAll = 0,
        pwmSwState_synchronousRectification_OFF = 1,
        pwmSwState_synchronousRectification_fixedDuty = 2,
        pwmSwState_synchronousRectification_active = 3
    }PwmSwState_Enum;
    int32_t pad;
}PwmSwState_EnumType;

extern  PwmSwState_EnumType pwmSwStateActive, pwmSwState;

typedef union{
    enum
    {
        powerFlow_PrimToSec = POWER_FLOW_PRIM_SEC,
        powerFlow_SecToPrim = POWER_FLOW_SEC_PRIM,
        powerFlow_intermediateState = POWER_FLOW_TRANSTION_STAGE,
    }PowerFlowState_Enum;
    int32_t pad;
}PowerFlowState_EnumType;

extern  PowerFlowState_EnumType powerFlowStateActive, powerFlowState;

//
// globals
//

extern GI gi;
extern float32_t giOut;
extern float32_t giError;
extern float32_t giPartialComputedValue;

extern GV gv;
extern float32_t gvOut;
extern float32_t gvError;
extern float32_t gvPartialComputedValue;

//
// Flags for clearing trips and closing the loop
//
extern volatile int32_t closeGiLoop;
extern volatile int32_t closeGvLoop;
extern volatile int32_t clearTrip;

extern volatile float32_t pwmFrequencyRef_Hz;
extern volatile float32_t pwmFrequency_Hz;
extern volatile float32_t pwmFrequencyPrev_Hz;

extern volatile float32_t pwmPeriodRef_pu;
extern float32_t pwmPeriod_pu;
extern float32_t pwmPeriodSlewed_pu;
extern float32_t pwmPeriodMin_pu;
extern float32_t pwmPeriodMax_pu;
extern float32_t pwmPeriodMax_ticks;
extern uint32_t pwmPeriod_ticks;
extern uint32_t countcheckISR3, countcheckISR2, countcheckISR1;
//
// 1- Primary Side (PFC-Inv/Bus)
//
extern float32_t iPrimSensed_Amps;
extern float32_t iPrimSensed_pu;
extern float32_t iPrimSensedOffset_pu;
extern float32_t iPrimSensedCalIntercept_pu;
extern float32_t iPrimSensedCalXvariable_pu;
extern EMAVG iPrimSensedAvg_pu;

extern float32_t iPrimTankSensed_Amps;
extern float32_t iPrimTankSensed_pu;
extern float32_t iPrimTankSensedOffset_pu;
extern float32_t iPrimTankSensedCalIntercept_pu;
extern float32_t iPrimTankSensedCalXvariable_pu;
extern EMAVG iPrimTankSensedAvg_pu;

extern float32_t vPrimSensed_Volts;
extern float32_t vPrimSensed_pu;
extern float32_t vPrimSensedOffset_pu;
extern EMAVG vPrimSensedAvg_pu;

extern float32_t vPrimRef_Volts;
extern float32_t vPrimRef_pu;
extern float32_t vPrimRefSlewed_pu;

extern volatile float32_t pwmDutyPrimRef_pu;
extern float32_t pwmDutyPrim_pu;
extern uint32_t pwmDutyAPrim_ticks;
extern uint32_t pwmDutyBPrim_ticks;

extern volatile float32_t pwmDeadBandREDPrimRef_ns;
extern uint32_t pwmDeadBandREDPrim_ticks;

extern volatile float32_t pwmDeadBandFEDPrimRef_ns;
extern uint32_t pwmDeadBandFEDPrim_ticks;

//
// 2-Secondary side (Battery)
//
extern float32_t iSecSensed_Amps;
extern float32_t iSecSensed_pu;
extern float32_t iSecSensedOffset_pu;
extern float32_t iSecSensedCalIntercept_pu;
extern float32_t iSecSensedCalXvariable_pu;
extern EMAVG iSecSensedAvg_pu;

extern volatile float32_t iSecRef_Amps;
extern float32_t iSecRef_pu;
extern float32_t iSecRefSlewed_pu;

extern float32_t vSecSensed_Volts;
extern float32_t vSecSensed_pu;
extern float32_t vSecSensedOffset_pu;

extern float32_t vSecRef_Volts;
extern float32_t vSecRef_pu;
extern float32_t vSecRefSlewed_pu;
extern EMAVG vSecSensedAvg_pu;

extern volatile float32_t pwmDutySecRef_pu;
extern float32_t pwmDutySec_pu;
extern uint32_t pwmDutyASec_ticks;
extern uint32_t pwmDutyBSec_ticks;

extern float32_t pwmDeadbandREDSec_ns;
extern uint16_t pwmDeadbandREDSec_ticks;

extern float32_t pwmDeadBandFEDSec_ns;
extern uint16_t pwmDeadbandFEDSec_ticks;

extern volatile float32_t pwmPhaseShiftPrimSecRef_ns;
extern float32_t pwmPhaseShiftPrimSec_ns;
extern int32_t pwmPhaseShiftPrimSec_ticks;
extern int16_t pwmPhaseShiftPrimSec_countDirection;


extern volatile uint16_t pwmISRTrig_ticks;

extern volatile uint32_t cla_task_counter;

// extern uint32_t slewSCIcommand;

//
// the function prototypes
//
#pragma FUNC_ALWAYS_INLINE(readSensedSignalsPrimToSecPowerFlow)
static inline void readSensedSignalsPrimToSecPowerFlow(void)
{
    iPrimSensed_pu = (float32_t)IPRIM_ADCREAD *
                                       ADC_PU_SCALE_FACTOR;
    iSecSensed_pu =  (float32_t)ISEC_ADCREAD_1 *
                                       ADC_PU_SCALE_FACTOR;
    vPrimSensed_pu = (float32_t)VPRIM_ADCREAD_1 *
                                       ADC_PU_SCALE_FACTOR;
    vSecSensed_pu =  (float32_t)VSEC_ADCREAD_1 *
                                        ADC_PU_SCALE_FACTOR;
}

#pragma FUNC_ALWAYS_INLINE(readSensedSignalsSecToPrimPowerFlow)
static inline void readSensedSignalsSecToPrimPowerFlow(void)
{
    // iPrimSensed_pu = ((float32_t)IPRIM_ADCREAD *
    //                                    ADC_PU_SCALE_FACTOR
    //                - iPrimSensedOffset_pu) * -2.0;

    // iSecSensed_pu =  ((float32_t)ISEC_ADCREAD *
    //                                    ADC_PU_SCALE_FACTOR
    //                - iSecSensedOffset_pu) * 2.0;
    // vPrimSensed_pu = ((float32_t)VPRIM_OVERSAMPLE_ADCREAD *
    //                                    ADC_PU_SCALE_FACTOR
    //                - vPrimSensedOffset_pu);
    // vSecSensed_pu =  ( (float32_t)VSEC_ADCREAD *
    //                                     ADC_PU_SCALE_FACTOR
    //                - vSecSensedOffset_pu);

    // vSecSensed_pu = vSecSensed_pu *
    //               (VSEC_MAX_SENSE_VOLTS / VSEC_OPTIMAL_RANGE_VOLTS);

    // iSecSensed_pu = (iSecSensed_pu *
    //                        iSecSensedCalXvariable_pu) +
    //                        iSecSensedCalIntercept_pu;
    // iPrimSensed_pu = (iPrimSensed_pu *
    //                         iPrimSensedCalXvariable_pu) +
    //                         iPrimSensedCalIntercept_pu;
}

static inline void calculatePWMDutyPeriodPhaseShiftTicks_primToSecPowerFlow(void)
{
    uint32_t temp;

    //
    // First calculate the hi-res ticks for the PWM
    // for this multiply by 2^16 , and divide by 1 (using left shift)
    // as the PWM is up down count mode
    //
    temp = ((uint32_t)(((float32_t)(pwmPeriodSlewed_pu *
                                   pwmPeriodMax_ticks) *
                       (float32_t)TWO_RAISED_TO_THE_POWER_SIXTEEN)))>> 1;

    //
    // next zero the lower 8 bits, as they are not part of TBPRDHR register
    //
    pwmPeriod_ticks = temp & 0xFFFFFF00;

    //
    // for hi-res the duty needs to set around period hence calculate
    // duty ticks as (period *(1-duty))
    //
    pwmDutyAPrim_ticks = (uint32_t)((float32_t)pwmPeriod_ticks *
                                         (float32_t)
                                         (1 - fabsf(pwmDutyPrim_pu)));

    pwmDutyBPrim_ticks = pwmDutyAPrim_ticks;

    //
    // the below is to get around the errata in HRPWM
    //
    if((pwmDutyAPrim_ticks & 0x00FF00) == 0)
    {
        pwmDutyAPrim_ticks = pwmDutyAPrim_ticks | 0x000100;
    }

    //
    // For secondary side the PWM is not centered around zero or period
    // hence multiply by 2 (<<1) for period*duty
    //
    pwmDutyASec_ticks = (uint32_t)((float32_t)pwmPeriod_ticks *
                                      (float32_t)
                                      (fabsf(pwmDutySec_pu))) << 1;

    //
    // for secondary side B ticks = period - duty_a
    //
    pwmDutyBSec_ticks = (pwmPeriod_ticks) -
                             pwmDutyASec_ticks;

    //
    // Note the actual delay seen may be 10ns different due to floating
    // point rounding
    // phaseShift = (TBPRD/2)-phase_shift_ns_ticks (per the PWM setup)
    // +2<<16 is added to accommodate for PWM sync delays on the chip
    //
    pwmPhaseShiftPrimSec_ticks =
            ((int32_t)(pwmPeriod_ticks >> 1) -
             (int32_t)((float32_t)pwmPhaseShiftPrimSec_ns *
                       PWMSYSCLOCK_FREQ_HZ * ONE_NANO_SEC *
                       TWO_RAISED_TO_THE_POWER_SIXTEEN) +
             ((int32_t)2 << 16));

    //
    // remove the hi-res part for the prim-sec shift
    //
    pwmPhaseShiftPrimSec_ticks = pwmPhaseShiftPrimSec_ticks &
                                        0xFFFF0000;

}

#pragma FUNC_ALWAYS_INLINE(calculatePWMDutyPeriodPhaseShiftTicks_secToPrimPowerFlow)
static inline void calculatePWMDutyPeriodPhaseShiftTicks_secToPrimPowerFlow(void)
{
    uint32_t temp;

    //
    // First calculate the hi-res ticks for the PWM
    // for this multiply by 2^16 , and divide by 1 (using left shift)
    // as the PWM is up down count mode
    //
    temp = ((uint32_t)(((float32_t)(pwmPeriod_pu *
                                   pwmPeriodMax_ticks))))>> 1;

    //
    // next zero the lower 8 bits, as they are not part of TBPRDHR register
    //
    pwmPeriod_ticks = temp & 0xFFFFFF00;

    //
    // for hi-res the duty needs to set around period hence calculate
    // duty ticks as (period *(1-duty))
    //
    pwmDutyASec_ticks = (uint32_t)((float32_t)pwmPeriod_ticks *
                                         (float32_t)
                                         (1 - fabsf(pwmDutySec_pu)));

    pwmDutyBSec_ticks = pwmDutyASec_ticks;

    //
    // for prim side, dutyA = period * duty_pu * 2.0 (<<1) because the duty is
    // not centered around zero or period
    //
    pwmDutyAPrim_ticks = (uint32_t)((float32_t)pwmPeriod_ticks *
                                      (float32_t)
                                      (fabsf(pwmDutyPrim_pu))) << 1;

    //
    // dutyB = period - dutyA
    //
    pwmDutyBPrim_ticks = (pwmPeriod_ticks) -
                             pwmDutyAPrim_ticks;

    //
    // the below is to get around the errata in HRPWM
    //
    if((pwmDutyASec_ticks & 0x00FF00) == 0)
    {
        pwmDutyASec_ticks = pwmDutyASec_ticks | 0x000100;
    }

    //
    // Note the actual delay seen may be 10ns different due to floating
    // point rounding
    // phaseShift = (TBPRD/2)-phase_shift_ns_ticks (per the PWM setup)
    // +2<<16 is added to accommodate for PWM sync delays on the chip
    //
    pwmPhaseShiftPrimSec_ticks =
            ((int32_t)(pwmPeriod_ticks >> 1) +
             (int32_t)((float32_t)pwmPhaseShiftPrimSec_ns *
                       PWMSYSCLOCK_FREQ_HZ * ONE_NANO_SEC) +
             ((int32_t)2 << 16));

}


#pragma FUNC_ALWAYS_INLINE(calculatePWMDeadBandPrimTicks)
static inline void calculatePWMDeadBandPrimTicks(void)
{
    uint32_t ticks;

    //
    // as we use double clock for the deadband there is a multiple by 2,
    // red_ticks= red_ns*pwm_clk_hz*one_ns*2^16
    // 2^16 multiply is (because of high res)
    //
    ticks = ((uint32_t)(pwmDeadBandREDPrimRef_ns *
                        (float32_t)TWO_RAISED_TO_THE_POWER_SIXTEEN *
                  ((float32_t)ONE_NANO_SEC) * PWMSYSCLOCK_FREQ_HZ * 2.0f));
    pwmDeadBandREDPrim_ticks = ( ticks & 0xFFFFFE00);

    ticks = ((uint32_t)(pwmDeadBandFEDPrimRef_ns *
                        (float32_t)TWO_RAISED_TO_THE_POWER_SIXTEEN *
                  ((float32_t)ONE_NANO_SEC) * PWMSYSCLOCK_FREQ_HZ * 2.0f));
    pwmDeadBandFEDPrim_ticks = ( ticks & 0xFFFFFE00);

}

#pragma FUNC_ALWAYS_INLINE(EPWM_setCounterCompareValue)
#pragma FUNC_ALWAYS_INLINE(EPWM_enablePhaseShiftLoad)
#pragma FUNC_ALWAYS_INLINE(runISR1)
static inline void runISR1(void)
{
    HAL_updatePWMDutyPeriodPhaseShift(pwmPeriod_ticks,
                      pwmDutyAPrim_ticks,
                      pwmDutyBPrim_ticks,
                      pwmDutyASec_ticks,
                      pwmDutyBSec_ticks,
                      pwmPhaseShiftPrimSec_ticks);

    EPWM_enablePhaseShiftLoad(SEC_LEG1_PWM_BASE);
    EPWM_enablePhaseShiftLoad(SEC_LEG2_PWM_BASE);

    
    // EPWM_setCounterCompareValue(ISR1_PERIPHERAL_TRIG_BASE,
    //                          EPWM_COUNTER_COMPARE_C, pwmISRTrig_ticks);
    

    //
    // write to COMPC or COMPD bits
    //
    #pragma diag_suppress = 173
    HWREGH(ISR1_PERIPHERAL_TRIG_BASE + EPWM_O_CMPC) =
                                        pwmISRTrig_ticks;
    #pragma diag_warning = 173
    HAL_clearISR1PeripheralInterruptFlag();
}


#pragma FUNC_ALWAYS_INLINE(runISR1_secondTime)
static inline void runISR1_secondTime(void)
{
    EPWM_disablePhaseShiftLoad(SEC_LEG1_PWM_BASE);
    EPWM_disablePhaseShiftLoad(SEC_LEG2_PWM_BASE);
    HAL_setupISR1Trigger(MIN_PWM_SWITCHING_FREQUENCY_HZ * 0.3);
    // EPWM_disableInterrupt(ISR1_PERIPHERAL_TRIG_BASE);
    HAL_clearISR1PeripheralInterruptFlag();
}


#pragma FUNC_ALWAYS_INLINE(runISR2_primToSecPowerFlow)
static inline void runISR2_primToSecPowerFlow(void)
{
    //
    // Read Current and Voltage Measurements
    //
    readSensedSignalsPrimToSecPowerFlow();
    updateBoardStatus();
    if(clearTrip == 1)
    {
        HAL_clearPWMTripFlags(PRIM_LEG1_PWM_BASE);
        HAL_clearPWMTripFlags(PRIM_LEG2_PWM_BASE);
        HAL_clearPWMTripFlags(SEC_LEG1_PWM_BASE);
        HAL_clearPWMTripFlags(SEC_LEG2_PWM_BASE);

        #if TEST_SETUP == TEST_SETUP_EMULATED_BATTERY
            closeGiLoop = 1;
        #endif

        clearTrip = 0;
    }

//     if(closeGiLoop == 1)
//     {
//         #if SFRA_TYPE == SFRA_CURRENT
//             giError = (SFRA_INJECT(iSecRefSlewed_pu) -
//                                              iSecSensed_pu);
//         #else
//             giError = (iSecRefSlewed_pu - iSecSensed_pu);
//         #endif

//         giOut = GI_IMMEDIATE_RUN(&gi,
//                                        giError,
//                                        giPartialComputedValue);

//         if(giOut > GI_OUT_MAX)
//         {
//             giOut = GI_OUT_MAX;
//         }
//         if(giOut < GI_OUT_MIN)
//         {
//             giOut = GI_OUT_MIN;
//         }

//         giPartialComputedValue = GI_PRECOMPUTE_RUN(&gi,
//                                                         giError,
//                                                         giOut);

//         if(giOut < pwmPeriodMin_pu)
//         {
//             giOut = pwmPeriodMin_pu;
//         }

//         pwmPeriod_pu = giOut;
//     }
//     else if(closeGvLoop == 1)
//     {

//         #if SFRA_TYPE == SFRA_VOLTAGE
//             gvError = (SFRA_INJECT(vSecRefSlewed_pu) -
//                                               vSecSensed_pu);
//         #else
//             gvError = (vSecRefSlewed_pu - vSecSensed_pu);
//         #endif

//         gvOut = GV_IMMEDIATE_RUN(&gv,
//                                        gvError,
//                                        gvPartialComputedValue);

//         if(gvOut > GV_OUT_MAX)
//         {
//             gvOut = GV_OUT_MAX;
//         }
//         if(gvOut < GV_OUT_MIN)
//         {
//             gvOut = GV_OUT_MIN;
//         }

//         gvPartialComputedValue = GV_PRECOMPUTE_RUN(&gv,
//                                                                 gvError,
//                                                                 gvOut);

//         if(gvOut < pwmPeriodMin_pu)
//         {
//             gvOut = pwmPeriodMin_pu;
//         }

//         pwmPeriod_pu = gvOut;
//     }
//     else
//     {

//         gi.d4 = pwmPeriod_pu;
//         gi.d5 = pwmPeriod_pu;
//         gi.d6 = pwmPeriod_pu;
//         gi.d7 = pwmPeriod_pu;

//         gv.d4 = pwmPeriod_pu;
//         gv.d5 = pwmPeriod_pu;
//         gv.d6 = pwmPeriod_pu;
//         gv.d7 = pwmPeriod_pu;

//         giError = (iSecRefSlewed_pu - iSecSensed_pu);
//         gi.d0 = giError;
//         gi.d1 = giError;
//         gi.d2 = giError;
//         gi.d3 = giError;

//         giPartialComputedValue = pwmPeriod_pu;

//         gvError = (vSecRefSlewed_pu - vSecSensed_pu);
//         gv.d0 = gvError;
//         gv.d1 = gvError;
//         gv.d2 = gvError;
//         gv.d3 = gvError;

//         gvPartialComputedValue = pwmPeriod_pu;

//         #if INCR_BUILD == OPEN_LOOP_BUILD
//             #if SFRA_TYPE != SFRA_DISABLED
//                 pwmPeriod_pu =
//                                 SFRA_INJECT(pwmPeriodRef_pu);

//             #else
//                 pwmPeriod_pu = pwmPeriodRef_pu;
//             #endif
//         #else
            pwmPeriod_pu = pwmPeriodRef_pu;
//         #endif

        if(pwmPeriod_pu < pwmPeriodMin_pu)
        {
            pwmPeriod_pu = pwmPeriodMin_pu;
        }
        else if(pwmPeriod_pu > 1.0)
        {
            pwmPeriod_pu = 1.0;
        }
    // }

    if(fabsf(pwmPeriod_pu - pwmPeriodSlewed_pu) > 
                        MAX_PERIOD_STEP_PU)
    {
        if(pwmPeriod_pu > pwmPeriodSlewed_pu)
        {
            pwmPeriodSlewed_pu = pwmPeriodSlewed_pu +
                                        MAX_PERIOD_STEP_PU;
        }
        else
        {
            pwmPeriodSlewed_pu = pwmPeriodSlewed_pu -
                                        MAX_PERIOD_STEP_PU;
        }
    }
    else
    {
        pwmPeriodSlewed_pu = pwmPeriod_pu;
    }
   pwmFrequency_Hz = (PWMSYSCLOCK_FREQ_HZ /
                             (pwmPeriodSlewed_pu *
                              pwmPeriodMax_ticks));


    // #if SFRA_TYPE == SFRA_CURRENT
    //     SFRA_COLLECT((float32_t *)& pwmPeriodSlewed_pu,
    //                  (float32_t *)&iSecSensed_pu);
    // #elif SFRA_TYPE == SFRA_VOLTAGE
    //     SFRA_COLLECT((float32_t *)& pwmPeriodSlewed_pu,
    //                  (float32_t *)&vSecSensed_pu);
    // #else
    //     //
    //     //this is the default condition, and also when SFRA is disabled
    //     //
    //     #ifndef __TMS320C28XX_CLA__
    //     slewSCIcommand++;
    //     if(slewSCIcommand > 20)
    //     {
    //         slewSCIcommand = 0;
    //         HAL_sendCommandOverSCI(
    //                    commandSentTo_AC_DC.CommandSentTo_AC_DC_Enum,
    //                            vPrimRef_Volts);
    //     }
    //     #endif
    // #endif



    HAL_clearISR2PeripheralInterruptFlag();

    //
    // Only issue ISR1 if there is a change in the PWM
    //
    if((pwmFrequencyPrev_Hz != pwmFrequency_Hz) ||
       (pwmPhaseShiftPrimSec_ns != pwmPhaseShiftPrimSecRef_ns) ||
       (pwmDutyPrim_pu != pwmDutyPrimRef_pu) ||
       (pwmDutySec_pu != pwmDutySecRef_pu))
    {
        pwmDutyPrim_pu = pwmDutyPrimRef_pu;
        pwmDutySec_pu = pwmDutySecRef_pu;
        pwmPhaseShiftPrimSec_ns = pwmPhaseShiftPrimSecRef_ns;

        calculatePWMDutyPeriodPhaseShiftTicks_primToSecPowerFlow();

        HAL_setupISR1Trigger(pwmFrequencyPrev_Hz);

        pwmFrequencyPrev_Hz = pwmFrequency_Hz;

        #if ISR1_RUNNING_ON == CLA_CORE
              pwmISRTrig_ticks =
                     ((TICKS_IN_PWM_FREQUENCY(pwmFrequency_Hz,
                                          PWMSYSCLOCK_FREQ_HZ)>> 1) - 20);
        #else
              pwmISRTrig_ticks =
                     ((TICKS_IN_PWM_FREQUENCY(pwmFrequency_Hz,
                                          PWMSYSCLOCK_FREQ_HZ)>> 1) - 27);
        #endif

    }
}

#pragma FUNC_ALWAYS_INLINE(runISR2_secToPrimPowerFlow)
static inline void runISR2_secToPrimPowerFlow(void)
{
    //
    // Read Current and Voltage Measurements
    //
    readSensedSignalsSecToPrimPowerFlow();

    if(clearTrip == 1)
    {
        HAL_clearPWMTripFlags(PRIM_LEG1_PWM_BASE);
        HAL_clearPWMTripFlags(PRIM_LEG2_PWM_BASE);
        HAL_clearPWMTripFlags(SEC_LEG1_PWM_BASE);
        HAL_clearPWMTripFlags(SEC_LEG2_PWM_BASE);

        clearTrip = 0;
    }

    if(closeGvLoop == 1)
    {

        #if SFRA_TYPE == SFRA_DISABLED
            gvError = (vPrimRefSlewed_pu - vPrimSensed_pu);
        #else
            gvError = (SFRA_INJECT(vPrimRefSlewed_pu) -
                                      vPrimSensed_pu);
        #endif

        gvOut = GV_IMMEDIATE_RUN(&gv,
                                       gvError,
                                       gvPartialComputedValue);

        if(gvOut > GV_OUT_MAX)
        {
            gvOut = GV_OUT_MAX;
        }
        if(gvOut < GV_OUT_MIN)
        {
            gvOut = GV_OUT_MIN;
        }

        gvPartialComputedValue = GV_PRECOMPUTE_RUN(&gv,
                                                        gvError,
                                                        gvOut);

        if(gvOut < pwmPeriodMin_pu)
        {
            gvOut = pwmPeriodMin_pu;
        }

        pwmPeriod_pu = gvOut;
    }
    else
    {

        gi.d4 = pwmPeriod_pu;
        gi.d5 = pwmPeriod_pu;
        gi.d6 = pwmPeriod_pu;
        gi.d7 = pwmPeriod_pu;

        gv.d4 = pwmPeriod_pu;
        gv.d5 = pwmPeriod_pu;
        gv.d6 = pwmPeriod_pu;
        gv.d7 = pwmPeriod_pu;

        gvError = (vPrimRefSlewed_pu - vPrimSensed_pu);
        gv.d0 = gvError;
        gv.d1 = gvError;
        gv.d2 = gvError;
        gv.d3 = gvError;

        gvPartialComputedValue = pwmPeriod_pu;

        #if INCR_BUILD == OPEN_LOOP_BUILD
            #if SFRA_TYPE == SFRA_DISABLED
                pwmPeriod_pu = pwmPeriodRef_pu;
            #else
                pwmPeriod_pu =
                        SFRA_INJECT(pwmPeriodRef_pu);
            #endif
        #else
            pwmPeriod_pu = pwmPeriodRef_pu;
        #endif

        if(pwmPeriod_pu < pwmPeriodMin_pu)
        {
            pwmPeriod_pu = pwmPeriodMin_pu;
        }
        else if(pwmPeriod_pu > 1.0)
        {
            pwmPeriod_pu = 1.0;
        }
    }

    if(fabsf(pwmPeriod_pu - pwmPeriodSlewed_pu) >
                            MAX_PERIOD_STEP_PU)
    {
        if(pwmPeriod_pu > pwmPeriodSlewed_pu)
        {
            pwmPeriodSlewed_pu = pwmPeriodSlewed_pu +
                                        MAX_PERIOD_STEP_PU;
        }
        else
        {
            pwmPeriodSlewed_pu = pwmPeriodSlewed_pu -
                                        MAX_PERIOD_STEP_PU;
        }
    }
    else
    {
        pwmPeriodSlewed_pu = pwmPeriod_pu;
    }

    pwmFrequency_Hz = (PWMSYSCLOCK_FREQ_HZ /
                             (pwmPeriodSlewed_pu *
                              pwmPeriodMax_ticks));

    HAL_clearISR2PeripheralInterruptFlag();

    //
    // Only issue ISR1 if there is a change in the PWM
    //
    if((pwmFrequencyPrev_Hz != pwmFrequency_Hz) ||
       (pwmPhaseShiftPrimSec_ns != pwmPhaseShiftPrimSecRef_ns) ||
       (pwmDutyPrim_pu != pwmDutyPrimRef_pu) ||
       (pwmDutySec_pu != pwmDutySecRef_pu))
    {

        pwmDutyPrim_pu = pwmDutyPrimRef_pu;
        pwmDutySec_pu = pwmDutySecRef_pu;
        pwmPhaseShiftPrimSec_ns = pwmPhaseShiftPrimSecRef_ns;

        calculatePWMDutyPeriodPhaseShiftTicks_secToPrimPowerFlow();

        HAL_setupISR1Trigger(pwmFrequencyPrev_Hz);

        pwmFrequencyPrev_Hz = pwmFrequency_Hz;

        #if ISR1_RUNNING_ON == CLA_CORE
              pwmISRTrig_ticks =
                     ((TICKS_IN_PWM_FREQUENCY(pwmFrequency_Hz,
                                          PWMSYSCLOCK_FREQ_HZ)>> 1) - 20);
        #else
              pwmISRTrig_ticks =
                     ((TICKS_IN_PWM_FREQUENCY(pwmFrequency_Hz,
                                          PWMSYSCLOCK_FREQ_HZ)>> 1) - 27);
        #endif

    }
}



#ifdef __cplusplus
}
#endif                                  /* extern "C" */
#endif
