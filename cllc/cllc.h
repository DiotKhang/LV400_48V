//#############################################################################
//
// FILE:   cllc.h
//
// TITLE: This is the solution header file.
//
//#############################################################################

#ifndef CLLC_H
#define CLLC_H

#ifdef __cplusplus

extern "C" {
#endif

//
// the includes & defines
//
#include <stdint.h>
#include <stddef.h>

// #ifndef __TMS320C28XX_CLA__
#include <math.h>
// #else
// #include <CLAmath.h>
// #endif

//
// this is the file generated by the powerSUITE page for this system
//
#include "cllc_settings.h"
#include "cllc_hal.h"

//
// Library header files
// DCL Library is used for the controller implementation
// GI -> DF13,
// GV -> DF13,
//

#ifndef __TMS320C28XX_CLA__
#include "DCL/DCLF32.h"
#define CLLC_GI DCL_DF13
#define CLLC_GV DCL_DF13

//
// GI on C28x ,run DCL_DF13 routines
//
#define CLLC_GI_IMMEDIATE_RUN DCL_runDF13_C5
#define CLLC_GI_PRECOMPUTE_RUN DCL_runDF13_C6

//
// GV on C28x ,run DCL_DF13 routines
//
#define CLLC_GV_RUN DCL_runDF13_C4
#define CLLC_GV_IMMEDIATE_RUN DCL_runDF13_C5
#define CLLC_GV_PRECOMPUTE_RUN DCL_runDF13_C6

#else
#include "DCL/DCLCLA.h"
#define CLLC_GI DCL_DF13_CLA
#define CLLC_GV DCL_DF13_CLA

//
// GI on C28x ,run DCL_DF13 routines
//
#define CLLC_GI_IMMEDIATE_RUN runDF13_L5
#define CLLC_GI_PRECOMPUTE_RUN runDF13_L6

//
// GV on C28x ,run DCL_DF13 routines
//
#define CLLC_GV_IMMEDIATE_RUN runDF13_L5
#define CLLC_GV_PRECOMPUTE_RUN runDF13_L6

#pragma FUNC_ALWAYS_INLINE(runDF13_L5)
#pragma FUNC_ALWAYS_INLINE(runDF13_L6)

//
//! \brief          Executes an immediate 3rd order Direct Form 1 controller on
//!                 the FPU32, Implemented as inline C function
//! \param[in] p    Pointer to the DCL_DF13 controller structure
//! \param[in] ek   The servo error
//! \param[in] vk   The partial pre-computed control effort
//! \return         The control effort
//!
static inline float32_t runDF13_L5(DCL_DF13_CLA *p,
                                             float32_t ek,
                                             float32_t vk)
{
    p->d4 = (ek * p->b0) + vk;

    return(p->d4);
}

//
//! \brief          Executes a partial pre-computed 3rd order
//!                 Direct Form 1 controller on the FPU32
//!                 Implemented as inline C function
//!                 Note: d0 not used
//! \param[in] p    Pointer to the DCL_DF13 controller structure
//! \param[in] ek   The servo error
//! \param[in] uk   The controller output in the previous sample interval
//! \return         The control effort
//!
//
static inline float32_t runDF13_L6(DCL_DF13_CLA *p,
                                             float32_t ek,
                                             float32_t uk)
{
    float32_t v9;

    v9 = (ek * p->b1) + (p->d1 * p->b2) + (p->d2 * p->b3)
         - (uk * p->a1) - (p->d5 * p->a2) - (p->d6 * p->a3);
    p->d2 = p->d1;
    p->d1 = ek;
    p->d6 = p->d5;
    p->d5 = uk;

    return(v9);
}

#endif

#include "utilities/emavg.h"

#pragma FUNC_ALWAYS_INLINE(EPWM_setActionQualifierContSWForceAction)

//
// Function to run the ISR3, for details see dataflow diagram in the user guide
//
void CLLC_runISR3(void);

//
// Function initialize the global variables
//
void CLLC_initGlobalVariables(void);

//
// Function reads the trip flags and updates the board status enum type variable
//
void CLLC_updateBoardStatus(void);

//
//
//
void CLLC_setBuildLevelIndicatorVariable(void);
void CLLC_changeSynchronousRectifierPwmBehavior(uint16_t powerFlow);

//
// typedefs
//

typedef union{
    enum
    {
        CLLC_Lab1 = 0,
        CLLC_Lab1_CLA = 1,
        CLLC_Lab2 = 2,
        CLLC_Lab2_CLA = 3,
        CLLC_Lab3 = 4,
        CLLC_Lab3_CLA = 5,
        CLLC_Lab4 = 6,
        CLLC_Lab4_CLA = 7,
        CLLC_Lab5 = 8,
        CLLC_Lab5_CLA = 9,
        CLLC_Lab6 = 10,
        CLLC_Lab6_CLA = 11,
        CLLC_Lab7 = 12,
        CLLC_Lab7_CLA = 13,
        CLLC_Lab8 = 14,
        CLLC_Lab8_CLA = 15,
        CLLC_undefinedLab = 12,
    }CLLC_Lab_Enum;
    int32_t pad;
}CLLC_Lab_EnumType;

extern  CLLC_Lab_EnumType CLLC_lab;

typedef union{
    enum
    {
        CLLC_noTrip = 0,
        CLLC_primOverCurrentTrip = 1,
        CLLC_secOverCurrentTrip = 2,
        CLLC_primOverVoltageTrip = 3,
        CLLC_secOverVoltageTrip = 4,
        CLLC_primTankOverCurrentTrip = 5,
    }CLLC_TripFlag_Enum;
    int32_t pad;
}CLLC_TripFlag_EnumType;

extern  CLLC_TripFlag_EnumType CLLC_TripFlag;

typedef union{
    enum
    {
        CLLC_pwmSwState_disabledAll = 0,
        CLLC_pwmSwState_synchronousRectification_OFF = 1,
        CLLC_pwmSwState_synchronousRectification_fixedDuty = 2,
        CLLC_pwmSwState_synchronousRectification_active = 3
    }CLLC_PwmSwState_Enum;
    int32_t pad;
}CLLC_PwmSwState_EnumType;

extern  CLLC_PwmSwState_EnumType CLLC_pwmSwStateActive, CLLC_pwmSwState;

typedef union{
    enum
    {
        CLLC_powerFlow_PrimToSec = CLLC_POWER_FLOW_PRIM_SEC,
        CLLC_powerFlow_SecToPrim = CLLC_POWER_FLOW_SEC_PRIM,
        CLLC_powerFlow_intermediateState = CLLC_POWER_FLOW_TRANSTION_STAGE,
    }CLLC_PowerFlowState_Enum;
    int32_t pad;
}CLLC_PowerFlowState_EnumType;

extern  CLLC_PowerFlowState_EnumType CLLC_powerFlowStateActive, CLLC_powerFlowState;

typedef union{
    enum
    {
       CLLC_precharge_none = 0,
       CLLC_precharge_starting = 1,
       CLLC_precharge_finished = 2
    }CLLC_PrechargeState_Enum;
    int32_t pad;
}CLLC_PrechargeState_EnumType;

extern CLLC_PrechargeState_EnumType CLLC_PrechargeState;
extern volatile uint32_t CLLC_precharge_count;
//
// globals
//

extern CLLC_GI CLLC_gi;
extern float32_t CLLC_giOut;
extern float32_t CLLC_giError;
extern float32_t CLLC_giPartialComputedValue;

extern CLLC_GV CLLC_gv;
extern float32_t CLLC_gvOut;
extern float32_t CLLC_gvError;
extern float32_t CLLC_gvPartialComputedValue;

//
// Flags for clearing trips and closing the loop
//
extern volatile int32_t CLLC_closeGiLoop;
extern volatile int32_t CLLC_closeGvLoop;
extern volatile int32_t CLLC_clearTrip;

extern volatile float32_t CLLC_pwmFrequencyRef_Hz;
extern volatile float32_t CLLC_pwmFrequency_Hz;
extern volatile float32_t CLLC_pwmFrequencyPrev_Hz;

extern volatile float32_t CLLC_pwmPeriodRef_pu;
extern float32_t CLLC_pwmPeriod_pu;
extern float32_t CLLC_pwmPeriodSlewed_pu;
extern float32_t CLLC_pwmPeriodMin_pu;
extern float32_t CLLC_pwmPeriodMax_pu;
extern float32_t CLLC_pwmPeriodMax_ticks;
extern uint32_t CLLC_pwmPeriod_ticks;
//
// 1- Primary Side (PFC-Inv/Bus)
//
extern float32_t CLLC_iPrimSensed_Amps;
extern float32_t CLLC_iPrimSensed_pu;
extern float32_t CLLC_iPrimSensedOffset_pu;
extern float32_t CLLC_iPrimSensedCalIntercept_pu;
extern float32_t CLLC_iPrimSensedCalXvariable_pu;
extern EMAVG CLLC_iPrimSensedAvg_pu;

extern float32_t CLLC_iPrimTankSensed_Amps;
extern float32_t CLLC_iPrimTankSensed_pu;
extern float32_t CLLC_iPrimTankSensedOffset_pu;
extern float32_t CLLC_iPrimTankSensedCalIntercept_pu;
extern float32_t CLLC_iPrimTankSensedCalXvariable_pu;
extern EMAVG CLLC_iPrimTankSensedAvg_pu;

extern float32_t CLLC_vPrimSensed_Volts;
extern float32_t CLLC_vPrimSensed_pu;
extern float32_t CLLC_vPrimSensedOffset_pu;
extern EMAVG CLLC_vPrimSensedAvg_pu;

extern float32_t CLLC_vPrimRef_Volts;
extern float32_t CLLC_vPrimRef_pu;
extern float32_t CLLC_vPrimRefSlewed_pu;

extern volatile float32_t CLLC_pwmDutyPrimRef_pu;
extern float32_t CLLC_pwmDutyPrim_pu;
extern uint32_t CLLC_pwmDutyAPrim_ticks;
extern uint32_t CLLC_pwmDutyBPrim_ticks;

extern volatile float32_t CLLC_pwmDeadBandREDPrimRef_ns;
extern uint32_t CLLC_pwmDeadBandREDPrim_ticks;

extern volatile float32_t CLLC_pwmDeadBandFEDPrimRef_ns;
extern uint32_t CLLC_pwmDeadBandFEDPrim_ticks;

//
// 2-Secondary side (Battery)
//
extern float32_t CLLC_iSecSensed_Amps;
extern float32_t CLLC_iSecSensed_pu;
extern float32_t CLLC_iSecSensedOffset_pu;
extern float32_t CLLC_iSecSensedCalIntercept_pu;
extern float32_t CLLC_iSecSensedCalXvariable_pu;
extern EMAVG CLLC_iSecSensedAvg_pu;

extern volatile float32_t CLLC_iSecRef_Amps;
extern float32_t CLLC_iSecRef_pu;
extern float32_t CLLC_iSecRefSlewed_pu;

extern float32_t CLLC_vSecSensed_Volts;
extern float32_t CLLC_vSecSensed_pu;
extern float32_t CLLC_vSecSensedOffset_pu;

extern float32_t CLLC_vSecRef_Volts;
extern float32_t CLLC_vSecRef_pu;
extern float32_t CLLC_vSecRefSlewed_pu;
extern EMAVG CLLC_vSecSensedAvg_pu;

extern volatile float32_t CLLC_pwmDutySecRef_pu;
extern float32_t CLLC_pwmDutySec_pu;
extern uint32_t CLLC_pwmDutyASec_ticks;
extern uint32_t CLLC_pwmDutyBSec_ticks;

extern float32_t CLLC_pwmDeadbandREDSec_ns;
extern uint16_t CLLC_pwmDeadbandREDSec_ticks;

extern float32_t CLLC_pwmDeadBandFEDSec_ns;
extern uint16_t CLLC_pwmDeadbandFEDSec_ticks;

extern volatile float32_t CLLC_pwmPhaseShiftPrimSecRef_ns;
extern float32_t CLLC_pwmPhaseShiftPrimSec_ns;
extern int32_t CLLC_pwmPhaseShiftPrimSec_ticks;
extern int16_t CLLC_pwmPhaseShiftPrimSec_countDirection;


extern volatile uint16_t CLLC_pwmISRTrig_ticks;

extern volatile uint32_t CLLC_cla_task_counter;

// extern uint32_t slewSCIcommand;

//
// the function prototypes
//
#pragma FUNC_ALWAYS_INLINE(CLLC_readSensedSignalsPrimToSecPowerFlow)
static inline void CLLC_readSensedSignalsPrimToSecPowerFlow(void)
{
    CLLC_iPrimSensed_pu = (float32_t)CLLC_IPRIM_ADCREAD *
                                       CLLC_ADC_PU_SCALE_FACTOR;
    CLLC_iSecSensed_pu =  (float32_t)CLLC_ISEC_ADCREAD_1 *
                                       CLLC_ADC_PU_SCALE_FACTOR;
    CLLC_vPrimSensed_pu = (float32_t)CLLC_VPRIM_ADCREAD_1 *
                                       CLLC_ADC_PU_SCALE_FACTOR;
    CLLC_vSecSensed_pu =  (float32_t)CLLC_VSEC_ADCREAD_1 *
                                        CLLC_ADC_PU_SCALE_FACTOR;
}

#pragma FUNC_ALWAYS_INLINE(CLLC_readSensedSignalsSecToPrimPowerFlow)
static inline void CLLC_readSensedSignalsSecToPrimPowerFlow(void)
{
    // iPrimSensed_pu = ((float32_t)IPRIM_ADCREAD *
    //                                    ADC_PU_SCALE_FACTOR
    //                - iPrimSensedOffset_pu) * -2.0;

    // iSecSensed_pu =  ((float32_t)ISEC_ADCREAD *
    //                                    ADC_PU_SCALE_FACTOR
    //                - iSecSensedOffset_pu) * 2.0;
    // vPrimSensed_pu = ((float32_t)VPRIM_OVERSAMPLE_ADCREAD *
    //                                    ADC_PU_SCALE_FACTOR
    //                - vPrimSensedOffset_pu);
    // vSecSensed_pu =  ( (float32_t)VSEC_ADCREAD *
    //                                     ADC_PU_SCALE_FACTOR
    //                - vSecSensedOffset_pu);

    // vSecSensed_pu = vSecSensed_pu *
    //               (VSEC_MAX_SENSE_VOLTS / VSEC_OPTIMAL_RANGE_VOLTS);

    // iSecSensed_pu = (iSecSensed_pu *
    //                        iSecSensedCalXvariable_pu) +
    //                        iSecSensedCalIntercept_pu;
    // iPrimSensed_pu = (iPrimSensed_pu *
    //                         iPrimSensedCalXvariable_pu) +
    //                         iPrimSensedCalIntercept_pu;
}

static inline void CLLC_calculatePWMDutyPeriodPhaseShiftTicks_primToSecPowerFlow(void)
{
    uint32_t temp;

    //
    // First calculate the hi-res ticks for the PWM
    // for this multiply by 2^16 , and divide by 1 (using left shift)
    // as the PWM is up down count mode
    //
    temp = ((uint32_t)(((float32_t)(CLLC_pwmPeriodSlewed_pu *
                                   CLLC_pwmPeriodMax_ticks) *
                       (float32_t)TWO_RAISED_TO_THE_POWER_SIXTEEN)))>> 1;

    //
    // next zero the lower 8 bits, as they are not part of TBPRDHR register
    //
    CLLC_pwmPeriod_ticks = temp & 0xFFFFFF00;

    //
    // for hi-res the duty needs to set around period hence calculate
    // duty ticks as (period *(1-duty))
    //
    CLLC_pwmDutyAPrim_ticks = (uint32_t)((float32_t)CLLC_pwmPeriod_ticks *
                                         (float32_t)
                                         (1 - fabsf(CLLC_pwmDutyPrim_pu)));

    CLLC_pwmDutyBPrim_ticks = CLLC_pwmDutyAPrim_ticks;

    //
    // the below is to get around the errata in HRPWM
    //
    if((CLLC_pwmDutyAPrim_ticks & 0x00FF00) == 0)
    {
        CLLC_pwmDutyAPrim_ticks = CLLC_pwmDutyAPrim_ticks | 0x000100;
    }

    //
    // For secondary side the PWM is not centered around zero or period
    // hence multiply by 2 (<<1) for period*duty
    //
    CLLC_pwmDutyASec_ticks = (uint32_t)((float32_t)CLLC_pwmPeriod_ticks *
                                      (float32_t)
                                      (fabsf(CLLC_pwmDutySec_pu))) << 1;

    //
    // for secondary side B ticks = period - duty_a
    //
    CLLC_pwmDutyBSec_ticks = (CLLC_pwmPeriod_ticks) -
                             CLLC_pwmDutyASec_ticks;

    //
    // Note the actual delay seen may be 10ns different due to floating
    // point rounding
    // phaseShift = (TBPRD/2)-phase_shift_ns_ticks (per the PWM setup)
    // +2<<16 is added to accommodate for PWM sync delays on the chip
    //
    CLLC_pwmPhaseShiftPrimSec_ticks =
            ((int32_t)(CLLC_pwmPeriod_ticks >> 1) -
             (int32_t)((float32_t)CLLC_pwmPhaseShiftPrimSec_ns *
                       CLLC_PWMSYSCLOCK_FREQ_HZ * ONE_NANO_SEC *
                       TWO_RAISED_TO_THE_POWER_SIXTEEN) +
             ((int32_t)2 << 16));

    //
    // remove the hi-res part for the prim-sec shift
    //
    CLLC_pwmPhaseShiftPrimSec_ticks = CLLC_pwmPhaseShiftPrimSec_ticks &
                                        0xFFFF0000;

}

#pragma FUNC_ALWAYS_INLINE(CLLC_calculatePWMDutyPeriodPhaseShiftTicks_secToPrimPowerFlow)
static inline void CLLC_calculatePWMDutyPeriodPhaseShiftTicks_secToPrimPowerFlow(void)
{
    uint32_t temp;

    //
    // First calculate the hi-res ticks for the PWM
    // for this multiply by 2^16 , and divide by 1 (using left shift)
    // as the PWM is up down count mode
    //
    temp = ((uint32_t)(((float32_t)(CLLC_pwmPeriod_pu *
                                   CLLC_pwmPeriodMax_ticks))))>> 1;

    //
    // next zero the lower 8 bits, as they are not part of TBPRDHR register
    //
    CLLC_pwmPeriod_ticks = temp & 0xFFFFFF00;

    //
    // for hi-res the duty needs to set around period hence calculate
    // duty ticks as (period *(1-duty))
    //
    CLLC_pwmDutyASec_ticks = (uint32_t)((float32_t)CLLC_pwmPeriod_ticks *
                                         (float32_t)
                                         (1 - fabsf(CLLC_pwmDutySec_pu)));

    CLLC_pwmDutyBSec_ticks = CLLC_pwmDutyASec_ticks;

    //
    // for prim side, dutyA = period * duty_pu * 2.0 (<<1) because the duty is
    // not centered around zero or period
    //
    CLLC_pwmDutyAPrim_ticks = (uint32_t)((float32_t)CLLC_pwmPeriod_ticks *
                                      (float32_t)
                                      (fabsf(CLLC_pwmDutyPrim_pu))) << 1;

    //
    // dutyB = period - dutyA
    //
    CLLC_pwmDutyBPrim_ticks = (CLLC_pwmPeriod_ticks) -
                             CLLC_pwmDutyAPrim_ticks;

    //
    // the below is to get around the errata in HRPWM
    //
    if((CLLC_pwmDutyASec_ticks & 0x00FF00) == 0)
    {
        CLLC_pwmDutyASec_ticks = CLLC_pwmDutyASec_ticks | 0x000100;
    }

    //
    // Note the actual delay seen may be 10ns different due to floating
    // point rounding
    // phaseShift = (TBPRD/2)-phase_shift_ns_ticks (per the PWM setup)
    // +2<<16 is added to accommodate for PWM sync delays on the chip
    //
    CLLC_pwmPhaseShiftPrimSec_ticks =
            ((int32_t)(CLLC_pwmPeriod_ticks >> 1) +
             (int32_t)((float32_t)CLLC_pwmPhaseShiftPrimSec_ns *
                       CLLC_PWMSYSCLOCK_FREQ_HZ * ONE_NANO_SEC) +
             ((int32_t)2 << 16));

}


#pragma FUNC_ALWAYS_INLINE(CLLC_calculatePWMDeadBandPrimTicks)
static inline void CLLC_calculatePWMDeadBandPrimTicks(void)
{
    uint32_t ticks;

    //
    // as we use double clock for the deadband there is a multiple by 2,
    // red_ticks= red_ns*pwm_clk_hz*one_ns*2^16
    // 2^16 multiply is (because of high res)
    //
    ticks = ((uint32_t)(CLLC_pwmDeadBandREDPrimRef_ns *
                        (float32_t)TWO_RAISED_TO_THE_POWER_SIXTEEN *
                  ((float32_t)ONE_NANO_SEC) * CLLC_PWMSYSCLOCK_FREQ_HZ * 2.0f));
    CLLC_pwmDeadBandREDPrim_ticks = ( ticks & 0xFFFFFE00);

    ticks = ((uint32_t)(CLLC_pwmDeadBandFEDPrimRef_ns *
                        (float32_t)TWO_RAISED_TO_THE_POWER_SIXTEEN *
                  ((float32_t)ONE_NANO_SEC) * CLLC_PWMSYSCLOCK_FREQ_HZ * 2.0f));
    CLLC_pwmDeadBandFEDPrim_ticks = ( ticks & 0xFFFFFE00);
}

#pragma FUNC_ALWAYS_INLINE(CLLC_precharge)
static inline void CLLC_precharge(void)
{
    if (CLLC_PrechargeState.CLLC_PrechargeState_Enum == CLLC_precharge_none)
    {
        // Set same phase between PWM1A & PWM2A
        EPWM_enablePhaseShiftLoad(CLLC_PRIM_LEG2_PWM_BASE);
        EALLOW;
        HWREG(CLLC_PRIM_LEG2_PWM_BASE + EPWM_O_TBPHS) = (int32_t)((float32_t)(CLLC_CONTROL_PRECHARGE_TPBRD_MAX) 
                                    * TWO_RAISED_TO_THE_POWER_SIXTEEN);
        EDIS;
        // Reset count
        CLLC_precharge_count = CLLC_CONTROL_PRECHARGE_COUNT;
    }
    if (CLLC_PrechargeState.CLLC_PrechargeState_Enum == CLLC_precharge_starting)
    {
        if (CLLC_precharge_count >= 1)
        {
            // Calculate Ramp-up phase-shift values
            CLLC_precharge_count--;
            EALLOW;
            HWREG(CLLC_PRIM_LEG2_PWM_BASE + EPWM_O_TBPHS) = (int32_t)((float32_t)(CLLC_CONTROL_PRECHARGE_TPBRD_MAX * 
            CLLC_precharge_count / CLLC_CONTROL_PRECHARGE_COUNT) * TWO_RAISED_TO_THE_POWER_SIXTEEN);
            EDIS;
        }
        else
        {
            // End pre-charge mode
            CLLC_PrechargeState.CLLC_PrechargeState_Enum = CLLC_precharge_finished;
            EPWM_disablePhaseShiftLoad(CLLC_PRIM_LEG2_PWM_BASE);
        }
    }
}

#pragma FUNC_ALWAYS_INLINE(EPWM_setCounterCompareValue)
#pragma FUNC_ALWAYS_INLINE(EPWM_enablePhaseShiftLoad)
#pragma FUNC_ALWAYS_INLINE(CLLC_runISR1)
static inline void CLLC_runISR1(void)
{
    CLLC_HAL_updatePWMDutyPeriodPhaseShift(CLLC_pwmPeriod_ticks,
                      CLLC_pwmDutyAPrim_ticks,
                      CLLC_pwmDutyBPrim_ticks,
                      CLLC_pwmDutyASec_ticks,
                      CLLC_pwmDutyBSec_ticks,
                      CLLC_pwmPhaseShiftPrimSec_ticks);

    EPWM_enablePhaseShiftLoad(CLLC_SEC_LEG1_PWM_BASE);
    EPWM_enablePhaseShiftLoad(CLLC_SEC_LEG2_PWM_BASE);
    
    HWREGH(CLLC_ISR1_PERIPHERAL_TRIG_BASE + EPWM_O_CMPA + EPWM_COUNTER_COMPARE_C) = 0xFFFF;

    //
    // write to COMPC or COMPD bits
    //
    #pragma diag_suppress = 173
    HWREGH(CLLC_ISR1_PERIPHERAL_TRIG_BASE + EPWM_O_ETCLR) = 1;
    #pragma diag_warning = 173
    CLLC_HAL_clearISR1PeripheralInterruptFlag();
}

#pragma FUNC_ALWAYS_INLINE(CLLC_runISR1_secondTime)
static inline void CLLC_runISR1_secondTime(void)
{
    EPWM_disablePhaseShiftLoad(CLLC_SEC_LEG1_PWM_BASE);
    EPWM_disablePhaseShiftLoad(CLLC_SEC_LEG2_PWM_BASE);
    CLLC_HAL_setupISR1Trigger(CLLC_MIN_PWM_SWITCHING_FREQUENCY_HZ * 0.3);
    CLLC_HAL_clearISR1PeripheralInterruptFlag();
}

#pragma FUNC_ALWAYS_INLINE(CLLC_runISR2_primToSecPowerFlow)
static inline void CLLC_runISR2_primToSecPowerFlow(void)
{
    //
    // Read Current and Voltage Measurements
    //
    CLLC_readSensedSignalsPrimToSecPowerFlow();
    CLLC_updateBoardStatus();

    // Let start by clearTrip = 1
    if(CLLC_clearTrip == 1)
    {
        CLLC_HAL_clearPWMTripFlags(CLLC_PRIM_LEG1_PWM_BASE);
        CLLC_HAL_clearPWMTripFlags(CLLC_PRIM_LEG2_PWM_BASE);
        CLLC_HAL_clearPWMTripFlags(CLLC_SEC_LEG1_PWM_BASE);
        CLLC_HAL_clearPWMTripFlags(CLLC_SEC_LEG2_PWM_BASE);

        CLLC_clearTrip = 0;

        // Ready to go to mode pre-charge
        CLLC_PrechargeState.CLLC_PrechargeState_Enum = CLLC_precharge_none;
    }
    if (CLLC_PrechargeState.CLLC_PrechargeState_Enum != CLLC_precharge_finished) CLLC_precharge();
    else
    {
        // Calculate control values in here
    }

    CLLC_pwmFrequency_Hz = (CLLC_PWMSYSCLOCK_FREQ_HZ /
                             (CLLC_pwmPeriodSlewed_pu *
                              CLLC_pwmPeriodMax_ticks));

    CLLC_HAL_clearISR2PeripheralInterruptFlag();

    //
    // Only issue ISR1 if there is a change in the PWM
    //
    if((CLLC_pwmFrequencyPrev_Hz != CLLC_pwmFrequency_Hz) ||
       (CLLC_pwmPhaseShiftPrimSec_ns != CLLC_pwmPhaseShiftPrimSecRef_ns) ||
       (CLLC_pwmDutyPrim_pu != CLLC_pwmDutyPrimRef_pu) ||
       (CLLC_pwmDutySec_pu != CLLC_pwmDutySecRef_pu))
    {
        CLLC_pwmDutyPrim_pu = CLLC_pwmDutyPrimRef_pu;
        CLLC_pwmDutySec_pu = CLLC_pwmDutySecRef_pu;
        CLLC_pwmPhaseShiftPrimSec_ns = CLLC_pwmPhaseShiftPrimSecRef_ns;

        CLLC_calculatePWMDutyPeriodPhaseShiftTicks_primToSecPowerFlow();

        CLLC_HAL_setupISR1Trigger(CLLC_pwmFrequencyPrev_Hz);

        CLLC_pwmFrequencyPrev_Hz = CLLC_pwmFrequency_Hz;

        #if CLLC_ISR1_RUNNING_ON == CLA_CORE
              CLLC_pwmISRTrig_ticks =
                     ((TICKS_IN_PWM_FREQUENCY(CLLC_pwmFrequency_Hz,
                                          CLLC_PWMSYSCLOCK_FREQ_HZ)>> 1) - 20);
        #else
              CLLC_pwmISRTrig_ticks =
                     ((TICKS_IN_PWM_FREQUENCY(CLLC_pwmFrequency_Hz,
                                          CLLC_PWMSYSCLOCK_FREQ_HZ)>> 1) - 27);
        #endif
    }
}

#pragma FUNC_ALWAYS_INLINE(CLLC_runISR2_secToPrimPowerFlow)
static inline void CLLC_runISR2_secToPrimPowerFlow(void)
{
    //
    // Read Current and Voltage Measurements
    //
    CLLC_readSensedSignalsSecToPrimPowerFlow();

    if(CLLC_clearTrip == 1)
    {
        CLLC_HAL_clearPWMTripFlags(CLLC_PRIM_LEG1_PWM_BASE);
        CLLC_HAL_clearPWMTripFlags(CLLC_PRIM_LEG2_PWM_BASE);
        CLLC_HAL_clearPWMTripFlags(CLLC_SEC_LEG1_PWM_BASE);
        CLLC_HAL_clearPWMTripFlags(CLLC_SEC_LEG2_PWM_BASE);

        CLLC_clearTrip = 0;
    }

    if(CLLC_closeGvLoop == 1)
    {

        #if SFRA_TYPE == SFRA_DISABLED
            CLLC_gvError = (CLLC_vPrimRefSlewed_pu - CLLC_vPrimSensed_pu);
        #else
            CLLC_gvError = (SFRA_INJECT(CLLC_vPrimRefSlewed_pu) -
                                      CLLC_vPrimSensed_pu);
        #endif

        CLLC_gvOut = CLLC_GV_IMMEDIATE_RUN(&CLLC_gv,
                                       CLLC_gvError,
                                       CLLC_gvPartialComputedValue);

        if(CLLC_gvOut > CLLC_GV_OUT_MAX)
        {
            CLLC_gvOut = CLLC_GV_OUT_MAX;
        }
        if(CLLC_gvOut < CLLC_GV_OUT_MIN)
        {
            CLLC_gvOut = CLLC_GV_OUT_MIN;
        }

        CLLC_gvPartialComputedValue = CLLC_GV_PRECOMPUTE_RUN(&CLLC_gv,
                                                        CLLC_gvError,
                                                        CLLC_gvOut);

        if(CLLC_gvOut < CLLC_pwmPeriodMin_pu)
        {
            CLLC_gvOut = CLLC_pwmPeriodMin_pu;
        }

        CLLC_pwmPeriod_pu = CLLC_gvOut;
    }
    else
    {

        CLLC_gi.d4 = CLLC_pwmPeriod_pu;
        CLLC_gi.d5 = CLLC_pwmPeriod_pu;
        CLLC_gi.d6 = CLLC_pwmPeriod_pu;
        CLLC_gi.d7 = CLLC_pwmPeriod_pu;

        CLLC_gv.d4 = CLLC_pwmPeriod_pu;
        CLLC_gv.d5 = CLLC_pwmPeriod_pu;
        CLLC_gv.d6 = CLLC_pwmPeriod_pu;
        CLLC_gv.d7 = CLLC_pwmPeriod_pu;

        CLLC_gvError = (CLLC_vPrimRefSlewed_pu - CLLC_vPrimSensed_pu);
        CLLC_gv.d0 = CLLC_gvError;
        CLLC_gv.d1 = CLLC_gvError;
        CLLC_gv.d2 = CLLC_gvError;
        CLLC_gv.d3 = CLLC_gvError;

        CLLC_gvPartialComputedValue = CLLC_pwmPeriod_pu;

        #if CLLC_INCR_BUILD == CLLC_OPEN_LOOP_BUILD
            #if CLLC_SFRA_TYPE == CLLC_SFRA_DISABLED
                CLLC_pwmPeriod_pu = CLLC_pwmPeriodRef_pu;
            #else
                CLLC_pwmPeriod_pu =
                        CLLC_SFRA_INJECT(CLLC_pwmPeriodRef_pu);
            #endif
        #else
            CLLC_pwmPeriod_pu = CLLC_pwmPeriodRef_pu;
        #endif

        if(CLLC_pwmPeriod_pu < CLLC_pwmPeriodMin_pu)
        {
            CLLC_pwmPeriod_pu = CLLC_pwmPeriodMin_pu;
        }
        else if(CLLC_pwmPeriod_pu > 1.0)
        {
            CLLC_pwmPeriod_pu = 1.0;
        }
    }

    if(fabsf(CLLC_pwmPeriod_pu - CLLC_pwmPeriodSlewed_pu) >
                            CLLC_MAX_PERIOD_STEP_PU)
    {
        if(CLLC_pwmPeriod_pu > CLLC_pwmPeriodSlewed_pu)
        {
            CLLC_pwmPeriodSlewed_pu = CLLC_pwmPeriodSlewed_pu +
                                        CLLC_MAX_PERIOD_STEP_PU;
        }
        else
        {
            CLLC_pwmPeriodSlewed_pu = CLLC_pwmPeriodSlewed_pu -
                                        CLLC_MAX_PERIOD_STEP_PU;
        }
    }
    else
    {
        CLLC_pwmPeriodSlewed_pu = CLLC_pwmPeriod_pu;
    }

    CLLC_pwmFrequency_Hz = (CLLC_PWMSYSCLOCK_FREQ_HZ /
                             (CLLC_pwmPeriodSlewed_pu *
                              CLLC_pwmPeriodMax_ticks));

    CLLC_HAL_clearISR2PeripheralInterruptFlag();

    //
    // Only issue ISR1 if there is a change in the PWM
    //
    if((CLLC_pwmFrequencyPrev_Hz != CLLC_pwmFrequency_Hz) ||
       (CLLC_pwmPhaseShiftPrimSec_ns != CLLC_pwmPhaseShiftPrimSecRef_ns) ||
       (CLLC_pwmDutyPrim_pu != CLLC_pwmDutyPrimRef_pu) ||
       (CLLC_pwmDutySec_pu != CLLC_pwmDutySecRef_pu))
    {

        CLLC_pwmDutyPrim_pu = CLLC_pwmDutyPrimRef_pu;
        CLLC_pwmDutySec_pu = CLLC_pwmDutySecRef_pu;
        CLLC_pwmPhaseShiftPrimSec_ns = CLLC_pwmPhaseShiftPrimSecRef_ns;

        CLLC_calculatePWMDutyPeriodPhaseShiftTicks_secToPrimPowerFlow();

        CLLC_HAL_setupISR1Trigger(CLLC_pwmFrequencyPrev_Hz);

        CLLC_pwmFrequencyPrev_Hz = CLLC_pwmFrequency_Hz;

        #if CLLC_ISR1_RUNNING_ON == CLA_CORE
              CLLC_pwmISRTrig_ticks =
                     ((TICKS_IN_PWM_FREQUENCY(CLLC_pwmFrequency_Hz,
                                          CLLC_PWMSYSCLOCK_FREQ_HZ)>> 1) - 20);
        #else
              CLLC_pwmISRTrig_ticks =
                     ((TICKS_IN_PWM_FREQUENCY(CLLC_pwmFrequency_Hz,
                                          CLLC_PWMSYSCLOCK_FREQ_HZ)>> 1) - 27);
        #endif

    }
}



#ifdef __cplusplus
}
#endif                                  /* extern "C" */
#endif
